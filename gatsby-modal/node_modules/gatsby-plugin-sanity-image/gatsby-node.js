var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};

// src/lib/bufferReplace.js
var require_bufferReplace = __commonJS((exports2, module2) => {
  __export(exports2, {
    default: () => bufferReplace_default
  });
  var bufferReplace2 = (buf, a, b) => {
    if (!Buffer.isBuffer(buf))
      buf = Buffer.from(buf);
    const idx = buf.indexOf(a);
    if (idx === -1)
      return buf;
    if (!Buffer.isBuffer(b))
      b = Buffer.from(b);
    const before = buf.slice(0, idx);
    const after = bufferReplace2(buf.slice(idx + a.length), a, b);
    const len = idx + b.length + after.length;
    return Buffer.concat([before, b, after], len);
  };
  module2.exports = bufferReplace2;
  var bufferReplace_default = bufferReplace2;
});

// src/gatsby-node.js
var fs = require("fs").promises;
var path = require("path");
var bufferReplace = require_bufferReplace();
exports.onPreExtractQueries = async ({store, getNodes}, {
  includeFragments = true,
  fragmentName = "Image",
  fragmentTypeName = "SanityImage",
  customImageTypes = [],
  altFieldName
}) => {
  if (!includeFragments)
    return;
  const nodes = getNodes();
  if (!nodes.some((node) => node.internal.type === "SanityImageAsset"))
    return;
  if (customImageTypes.length)
    fragmentTypeName = fragmentTypeName === "SanityImage" ? "SanityImageEntity" : fragmentTypeName;
  const fragments = await fs.readFile(path.resolve(__dirname, "fragments.js")).then(replaceFragmentName(fragmentName)).then(replaceFragmentTypeName(fragmentTypeName)).then(configureAltTextSupport(altFieldName));
  const {program} = store.getState();
  const basePath = program.directory;
  const fragmentCachePath = path.resolve(basePath, ".cache/fragments/gatsby-plugin-sanity-image.js");
  return fs.writeFile(fragmentCachePath, fragments);
};
exports.onCreateWebpackConfig = ({stage, rules, loaders, plugins, actions}, {dataset, projectId, altFieldName, useCdn = true, defaultImageConfig = null}) => {
  actions.setWebpackConfig({
    plugins: [
      plugins.define({
        __GATSBY_PLUGIN_SANITY_IMAGE__DATASET__: JSON.stringify(dataset),
        __GATSBY_PLUGIN_SANITY_IMAGE__PROJECTID__: JSON.stringify(projectId),
        __GATSBY_PLUGIN_SANITY_IMAGE__USECDN__: JSON.stringify(useCdn),
        __GATSBY_PLUGIN_SANITY_IMAGE__ALT_FIELD__: JSON.stringify(altFieldName),
        __GATSBY_PLUGIN_SANITY_IMAGE__DEFAULT_IMAGE_CONFIG__: JSON.stringify(defaultImageConfig)
      })
    ]
  });
};
exports.sourceNodes = ({actions: {createTypes}}, {customImageTypes = [], fragmentTypeName = "SanityImage"}) => {
  if (!customImageTypes || customImageTypes.length === 0)
    return;
  const interfaceTypeName = fragmentTypeName === "SanityImage" ? "SanityImageEntity" : fragmentTypeName;
  const imageFields = `
    asset: SanityImageAsset
    hotspot: SanityImageHotspot
    crop: SanityImageCrop
  `;
  const typeDefs = ["SanityImage", ...customImageTypes].map((type) => `type ${type} implements ${interfaceTypeName} { ${imageFields} }`).join("\n\n");
  createTypes(`
    interface ${interfaceTypeName} {
      ${imageFields}
    }

    ${typeDefs}
  `);
};
var replaceFragmentName = (fragmentName) => (data) => bufferReplace(data, "__FRAGMENT_NAME__", fragmentName);
var replaceFragmentTypeName = (fragmentTypeName) => (data) => bufferReplace(data, "__FRAGMENT_TYPE_NAME__", fragmentTypeName);
var configureAltTextSupport = (altFieldName) => (data) => bufferReplace(data, "__OPTIONAL_ALT_SUPPORT__", altFieldName || "");
